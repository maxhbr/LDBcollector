{"export_restricted":0,"license":"GPL-2.0+ WITH Exception","packname":"","patent":0,"pattern":"free software; you can redistribute it and\/or\r\n# modify it under the terms of the GNU General Public License as\r\n# published by the Free Software Foundation; either version 2 of\r\n# the License, or (at your option) any later version.\r\n#\r\n# This program is distributed in the hope that it will be useful,\r\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n# General Public License for more details.\r\n#\r\n# You should have received a copy of the GNU General Public License\r\n# along with this program; if not, write to the Free Software\r\n# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.\r\n#\r\n# As a special exception, g10 Code GmbH gives unlimited permission to\r\n# copy, distribute and modify the C source files that are the output\r\n# of mkstrtable.awk.  You need not follow the terms of the GNU General\r\n# Public License when using or distributing such scripts, even though\r\n# portions of the text of mkstrtable.awk appear in them.  The GNU\r\n# General Public License (GPL) does govern all other use of the material\r\n# that constitutes the mkstrtable.awk program.\r\n#\r\n# Certain portions of the mkstrtable.awk source text are designed to be\r\n# copied (in certain cases, depending on the input) into the output of\r\n# mkstrtable.awk.  We call these the \"data\" portions.  The rest of the\r\n# mkstrtable.awk source text consists of comments plus executable code\r\n# that decides which of the data portions to output in any given case.\r\n# We call these comments and executable code the \"non-data\" portions.\r\n# mkstrtable.h never copies any of the non-data portions into its output.\r\n#\r\n# This special exception to the GPL applies to versions of mkstrtable.awk\r\n# released by g10 Code GmbH.  When you make and distribute a modified version\r\n# of mkstrtable.awk, you may extend this special exception to the GPL to\r\n# apply to your modified version as well, *unless* your modified version\r\n# has the potential to copy into its output some of the text that was the\r\n# non-data portion of the version that you started with.  (In other words,\r\n# unless your change moves or copies text from the non-data portions to the\r\n# data portions.)  If your modification has such potential, you must delete\r\n# any notice of this special exception to the GPL from your modified version.\r\n\r\n# This script outputs a source file that does define the following\r\n# symbols:\r\n#\r\n# static const char msgstr[];\r\n# A string containing all messages in the list.\r\n#\r\n# static const int msgidx[];\r\n# A list of index numbers, one for each message, that points to the\r\n# beginning of the string in msgstr.\r\n#\r\n# msgidxof (code);\r\n# A macro that maps code numbers to idx numbers.  If a DEFAULT MESSAGE\r\n# is provided (see below), its index will be returned for unknown codes.\r\n# Otherwise -1 is returned for codes that do not appear in the list.\r\n# You can lookup the message with code CODE with:\r\n# msgstr + msgidx[msgidxof (code)].\r\n#\r\n# The input file has the following format:\r\n# CODE1\t...\tMESSAGE1\t(code nr, <tab>, something, <tab>, msg)\r\n# CODE2\t...\tMESSAGE2\t(code nr, <tab>, something, <tab>, msg)\r\n# ...\r\n# CODEn\t...\tMESSAGEn\t(code nr, <tab>, something, <tab>, msg)\r\n# \t...\tDEFAULT-MESSAGE\t(<tab>, something, <tab>, fall-back msg)\r\n#\r\n# Comments (starting with # and ending at the end of the line) are removed,\r\n# as is trailing whitespace.  The last line is optional; if no DEFAULT\r\n# MESSAGE is given, msgidxof will return the number -1 for unknown\r\n# index numbers.\r\n#\r\n# The field to be used is specified with the variable \"textidx\" on\r\n# the command line.  It defaults to 2.\r\n#\r\n# The variable nogettext can be set to 1 to suppress gettext markers.\r\n#\r\n# The variable prefix can be used to prepend a string to each message.\r\n#\r\n# The variable namespace can be used to prepend a string to each\r\n# variable and macro name.\r\n\r\nBEGIN {\r\n  FS = \"[\\t]+\";\r\n# cpos holds the current position in the message string.\r\n  cpos = 0;\r\n# msg holds the number of messages.\r\n  msg = 0;\r\n  print \"\/* Output of mkstrtable.awk.  DO NOT EDIT.  *\/\";\r\n  print \"\";\r\n  header = 1;\r\n  if (textidx == 0)\r\n    textidx = 2;\r\n# nogettext can be set to 1 to suppress gettext noop markers.\r\n}\r\n\r\n\/^#\/ { next; }\r\n\r\nheader {\r\n  if ($1 ~ \/^[0123456789]+$\/)\r\n    {\r\n      print \"\/* The purpose of this complex string table is to produce\";\r\n      print \"   optimal code with a minimum of relocations.  *\/\";\r\n      print \"\";\r\n      print \"static const char \" namespace \"msgstr[] = \";\r\n      header = 0;\r\n    }\r\n  else\r\n    print;\r\n}\r\n\r\n!header {\r\n  sub (\/\\#.+\/, \"\");\r\n  sub (\/[ \t]+$\/, \"\"); # Strip trailing space and tab characters.\r\n\r\n  if (\/^$\/)\r\n    next;\r\n\r\n# Print the string msgstr line by line.  We delay output by one line to be able\r\n# to treat the last line differently (see END).\r\n  if (last_msgstr)\r\n    {\r\n      if (nogettext)\r\n\tprint \"  \\\"\" last_msgstr \"\\\" \\\"\\\\0\\\"\";\r\n      else\r\n\tprint \"  gettext_noop (\\\"\" last_msgstr \"\\\") \\\"\\\\0\\\"\";\r\n    }\r\n  last_msgstr = prefix $textidx;\r\n\r\n# Remember the error code and msgidx of each error message.\r\n  code[msg] = $1;\r\n  pos[msg] = cpos;\r\n  cpos += length (last_msgstr) + 1;\r\n  msg++;\r\n\r\n  if ($1 == \"\")\r\n    {\r\n      has_default = 1;\r\n      exit;\r\n    }\r\n}\r\nEND {\r\n  if (has_default)\r\n    coded_msgs = msg - 1;\r\n  else\r\n    coded_msgs = msg;\r\n\r\n  if (nogettext)\r\n    print \"  \\\"\" last_msgstr \"\\\";\";\r\n  else\r\n    print \"  gettext_noop (\\\"\" last_msgstr \"\\\");\";\r\n  print \"\";\r\n  print \"static const int \" namespace \"msgidx[] =\";\r\n  print \"  {\";\r\n  for (i = 0; i < coded_msgs; i++)\r\n    print \"    \" pos[i] \",\";\r\n  print \"    \" pos[coded_msgs];\r\n  print \"  };\";\r\n  print \"\";\r\n  print \"static GPG_ERR_INLINE int\";\r\n  print namespace \"msgidxof (int code)\";\r\n  print \"{\";\r\n  print \"  return (0 ? 0\";\r\n\r\n# Gather the ranges.\r\n  skip = code[0];\r\n  start = code[0];\r\n  stop = code[0];\r\n  for (i = 1; i < coded_msgs; i++)\r\n    {\r\n      if (code[i] == stop + 1)\r\n\tstop++;\r\n      else\r\n\t{\r\n\t  print \"  : ((code >= \" start \") && (code <= \" stop \")) ? (code - \" \\\r\n            skip \")\";\r\n\t  skip += code[i] - stop - 1;\r\n\t  start = code[i];\r\n\t  stop = code[i];\r\n\t}\r\n    }\r\n  print \"  : ((code >= \" start \") && (code <= \" stop \")) ? (code - \" \\\r\n    skip \")\";\r\n  if (has_default)\r\n    print \"  : \" stop + 1 \" - \" skip \");\";\r\n  else\r\n    print \"  : -1);\";\r\n  print","risk":2,"spdx":"","trademark":0,"unique_id":"9024135f-5009-40a9-a2fc-7298ec4a83b2"}