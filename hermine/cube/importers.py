# SPDX-FileCopyrightText: 2021 Hermine-team <hermine@inno3.fr>
# SPDX-FileCopyrightText: 2022 Martin Delabre <gitlab.com/delabre.martin>
#
# SPDX-License-Identifier: AGPL-3.0-only

from datetime import datetime
import json
from typing import Optional
import logging

from django.db import transaction
from packageurl import PackageURL
from rest_framework.parsers import JSONParser
from spdx.parsers import (
    jsonparser,
    jsonyamlxmlbuilders,
    tagvaluebuilders,
    rdf,
    rdfbuilders,
    tagvalue,
    xmlparser,
    yamlparser,
)
from spdx.parsers.loggers import StandardLogger
import spdx_license_list

from cube.models import Component, Version, Usage
from cube.serializers import LicenseSerializer

logger = logging.getLogger(__name__)


def is_spdx(expression):
    # Checks if elements of an expression are spdx compliant
    # But doesn't check if the expression itself is.
    # Like "AND OR MIT BSD-3-Clause" would pass
    operators = ["AND", "OR", "WITH", "(", ")"]
    chunks = expression.split()
    valid = True
    for chunk in chunks:
        if (chunk not in operators) and (chunk not in spdx_license_list.LICENSES):
            valid = False
            print(chunk, "not spdx")
    return valid


@transaction.atomic()
def import_ort_evaluated_model_json_file(
    json_file, release_idk, replace=False, defaults: Optional[dict] = None
):
    if defaults is None:
        defaults = {}
    data = json.load(json_file)

    paths = data["paths"]
    scopes = data["scopes"]
    packages = data["packages"]
    if replace:
        Usage.objects.filter(release=release_idk).delete()

    for package in packages:
        if package["is_project"]:
            continue
        current_purl = package.get("purl")
        package_id = package["id"]
        # If there is no Purl field, we recreate it from the ORT ID

        if current_purl is None:
            logger.info(f"Purl is null for {package_id}")
            p_type = package_id[0 : package_id.find(":")]
            p_version = package_id[package_id.rfind(":") + 1 :]
            if len(p_version) == 0:
                p_version = "AUTOGENERATED"
            p_name = package["id"][
                package["id"].find(":") + 1 : package["id"].rfind(":")
            ].replace(":", "/")
            # TODO Maybe trace the fact that it's generated
            current_purl = str(
                PackageURL(type=p_type.lower(), name=p_name, version=p_version)
            )
        purl = PackageURL.from_string(current_purl)
        component, component_created = Component.objects.get_or_create(
            name=purl.name,
            defaults={
                "description": package.get("description", ""),
                "homepage_url": package.get("homepage_url", ""),
            },
        )
        if component_created:
            logger.info(f"Component {component.name} created")

        declared_licenses_indices = package.get("declared_licenses", "")
        if declared_licenses_indices:
            declared_licenses = " ; ".join(
                [
                    data["licenses"][license_index]["id"]
                    for license_index in declared_licenses_indices
                ]
            )
        else:
            declared_licenses = ""
        version, version_created = Version.objects.get_or_create(
            component=component,
            version_number=current_purl.split("@")[1],
            defaults={
                "declared_license_expr": declared_licenses,
                "spdx_valid_license_expr": package["declared_licenses_processed"].get(
                    "spdx_expression", ""
                ),
                # TODO : support ORT scanner function
                # "scanned_licenses":
                "purl": current_purl,
            },
        )
        if version_created:
            logger.info(
                f"Version {version.version_number} created for component {component.name}"
            )
        defaults = {}
        path_ids = package.get("paths")
        if path_ids:
            for path_id in path_ids:
                path = paths[path_id]
                scope_id = path.get("scope")
                project_id = path.get("project")
                scope_name = scopes[scope_id]["name"]
                project_name = packages[project_id]["id"]
                Usage.objects.get_or_create(
                    version_id=version.id,
                    release_id=release_idk,
                    scope=scope_name,
                    project=project_name,
                    defaults=defaults,
                )


@transaction.atomic()
def import_spdx_file(
    spdx_file, release_id, replace=False, defaults: Optional[dict] = None
):
    if defaults is None:
        defaults = {}
    # Importing SPDX BOM yaml
    logger.info("SPDX import started")
    document, error = parse_spdx_file(spdx_file)
    if error:
        logger.warning(
            "SPDX file contains errors (printed above), but import continuesâ€¦"
        )

    if replace:
        Usage.objects.filter(release=release_id).delete()

    for package in document.packages:
        current_scope = "Global"
        comp_name = package.name.rsplit("@")[0]
        comp_url = package.download_location or ""
        comp, created = Component.objects.get_or_create(
            name=comp_name, defaults={"homepage_url": comp_url}
        )
        # If necessary create version
        vers_number = package.version or "Current"
        vers_lic_decl = package.license_declared.identifier
        # SPDX output sometimes return "NOASSERTION" instead of an empty value.
        if vers_lic_decl == "NOASSERTION":
            vers_lic_decl = ""
        vers_lic_concl = package.conc_lics.identifier
        if vers_lic_concl == "NOASSERTION":
            vers_lic_concl = ""
        vers, vcreated = Version.objects.get_or_create(
            component=comp,
            version_number=vers_number,
            defaults={
                "declared_license_expr": vers_lic_decl,
                "spdx_valid_license_expr": vers_lic_concl,
            },
        )
        version_id = vers.id
        Usage.objects.get_or_create(
            version_id=version_id,
            release_id=release_id,
            scope=current_scope,
            defaults={"addition_method": "Scan", **defaults},
        )
    logger.info("SPDX import done", datetime.now())


# Function derivated from
# https://github.com/spdx/tools-python/blob/21ea183f72a1179c62ec146a992ec5642cc5f002/spdx/parsers/parse_anything.py
# SPDX-FileCopyrightText: spdx contributors
# SPDX-License-Identifier: Apache-2.0
def parse_spdx_file(spdx_file):
    builder_module = jsonyamlxmlbuilders
    filename = spdx_file.name
    read_data = False
    if filename.endswith(".rdf") or filename.endswith(".rdf.xml"):
        parsing_module = rdf
        builder_module = rdfbuilders
    elif filename.endswith(".spdx"):
        parsing_module = rdf
        builder_module = rdfbuilders
    elif filename.endswith(".tag"):
        parsing_module = tagvalue
        builder_module = tagvaluebuilders
        read_data = True
    elif filename.endswith(".json"):
        parsing_module = jsonparser
    elif filename.endswith(".xml"):
        parsing_module = xmlparser
    elif filename.endswith(".yaml") or filename.endswith(".yml"):
        parsing_module = yamlparser
    else:
        return None, "FileType Not Supported" + filename

    parser = parsing_module.Parser(builder_module.Builder(), StandardLogger())
    if hasattr(parser, "build"):
        parser.build()
    if read_data:
        data = spdx_file.read()
        return parser.parse(data)
    else:
        return parser.parse(spdx_file)
