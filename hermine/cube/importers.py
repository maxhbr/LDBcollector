# SPDX-FileCopyrightText: 2021 Hermine-team <hermine@inno3.fr>
# SPDX-FileCopyrightText: 2022 Martin Delabre <gitlab.com/delabre.martin>
#
# SPDX-License-Identifier: AGPL-3.0-only

from datetime import datetime
import json
import logging

from django.db import transaction
from packageurl import PackageURL
from spdx.parsers import (
    jsonparser,
    jsonyamlxmlbuilders,
    tagvaluebuilders,
    rdf,
    rdfbuilders,
    tagvalue,
    xmlparser,
    yamlparser,
)
from spdx.parsers.loggers import StandardLogger

from cube.models import Component, Version, Usage, Exploitation
from cube.utils.licenses import simplified

logger = logging.getLogger(__name__)


class SBOMImportFailure(Exception):
    pass


@transaction.atomic()
def import_ort_evaluated_model_json_file(
    json_file, release_idk, replace=False, linking: str = ""
):
    try:
        data = json.load(json_file)
    except ValueError:
        raise SBOMImportFailure("Please check file format.")

    try:
        paths = data["paths"]
        scopes = data["scopes"]
        packages = data["packages"]
        licenses = data["licenses"]
    except KeyError:
        raise SBOMImportFailure("Please check file format.")

    if replace:
        Usage.objects.filter(release=release_idk).delete()

    for package in packages:
        if package["is_project"]:
            continue
        package_id = package["id"]

        # If there is no Purl field, we recreate it from the ORT ID
        if (current_purl := package.get("purl")) is None:
            logger.info(f"Purl is null for {package_id}")
            p_type = package_id[0 : package_id.find(":")]
            p_version = package_id[package_id.rfind(":") + 1 :]
            if len(p_version) == 0:
                p_version = "AUTOGENERATED"
            p_name = package["id"][
                package["id"].find(":") + 1 : package["id"].rfind(":")
            ].replace(":", "/")
            # TODO Maybe trace the fact that it's generated
            current_purl = str(
                PackageURL(type=p_type.lower(), name=p_name, version=p_version)
            )  # p_name can contain namespace at this point, not a problem because they are stored together anyway

        purl = PackageURL.from_string(current_purl)
        component, component_created = Component.objects.get_or_create(
            name=f"{purl.namespace}/{purl.name}" if purl.namespace else purl.name,
            package_repo=purl.type,
            defaults={
                "description": package.get("description", ""),
                "homepage_url": package.get("homepage_url", ""),
            },
        )
        if component_created:
            logger.info(f"Component {component.name} created")

        declared_licenses_indices = package.get("declared_licenses", "")
        if declared_licenses_indices:
            declared_licenses = " ; ".join(
                [
                    licenses[license_index]["id"]
                    for license_index in declared_licenses_indices
                ]
            )
        else:
            declared_licenses = ""
        spdx_valid_license = package["declared_licenses_processed"].get(
            "spdx_expression", ""
        )
        if spdx_valid_license == "NOASSERTON":
            spdx_valid_license = ""
        version, version_created = Version.objects.get_or_create(
            component=component,
            version_number=current_purl.split("@")[1],
            defaults={
                "declared_license_expr": declared_licenses,
                "spdx_valid_license_expr": spdx_valid_license
                and simplified(spdx_valid_license),
                # TODO : support ORT scanner function
                # "scanned_licenses":
                "purl": current_purl,
            },
        )
        if version_created:
            logger.info(
                f"Version {version.version_number} created for component {component.name}"
            )
        path_ids = package.get("paths", [])
        if path_ids:
            for path_id in path_ids:
                path = paths[path_id]
                scope_id = path.get("scope")
                project_id = path.get("project")
                scope_name = scopes[scope_id]["name"]
                project_name = packages[project_id]["id"]
                try:
                    exploitation = Exploitation.objects.get(
                        release=release_idk, project=project_name, scope=scope_name
                    ).exploitation
                except Exploitation.DoesNotExist:
                    exploitation = ""
                Usage.objects.get_or_create(
                    version_id=version.id,
                    release_id=release_idk,
                    scope=scope_name,
                    project=project_name,
                    linking=linking,
                    exploitation=exploitation,
                )
        else:
            scope_name = Usage.DEFAULT_SCOPE
            project_name = Usage.DEFAULT_PROJECT
            try:
                exploitation = Exploitation.objects.get(
                    release=release_idk, project=project_name, scope=scope_name
                ).exploitation
            except Exploitation.DoesNotExist:
                exploitation = ""
            Usage.objects.get_or_create(
                version_id=version.id,
                release_id=release_idk,
                scope=scope_name,
                project=project_name,
                linking=linking,
                exploitation=exploitation,
            )


@transaction.atomic()
def import_spdx_file(spdx_file, release_id, replace=False, linking: str = ""):
    # Importing SPDX BOM yaml
    logger.info("SPDX import started")
    document, error = parse_spdx_file(spdx_file)

    if document is None:
        raise SBOMImportFailure("Please check file format.")

    if error:
        logger.warning(
            "SPDX file contains errors (printed above), but import continuesâ€¦"
        )

    if replace:
        Usage.objects.filter(release=release_id).delete()

    for package in document.packages:
        current_scope = Usage.DEFAULT_SCOPE
        current_project = Usage.DEFAULT_PROJECT
        comp_name = package.name.rsplit("@")[0]
        comp_url = package.download_location or ""
        component, created = Component.objects.get_or_create(
            name=comp_name, defaults={"homepage_url": comp_url}
        )

        if not package.license_declared:
            declared_license = "NOASSERTION"
        else:
            declared_license = package.license_declared.identifier

        # SPDX output sometimes return "NOASSERTION" instead of an empty value
        # we want to keep it as declared but it is not a valid license expression
        if not package.conc_lics or package.conc_lics.identifier == "NOASSERTION":
            concluded_license = ""
        else:
            concluded_license = package.conc_lics.identifier

        version, created = Version.objects.get_or_create(
            component=component,
            version_number=package.version or "Current",
            defaults={
                "declared_license_expr": declared_license,
                "spdx_valid_license_expr": concluded_license
                and simplified(concluded_license),
            },
        )

        try:
            exploitation = Exploitation.objects.get(
                release=release_id, project=current_project, scope=current_scope
            ).exploitation
        except Exploitation.DoesNotExist:
            exploitation = ""

        Usage.objects.get_or_create(
            version_id=version.id,
            release_id=release_id,
            project=current_project,
            exploitation=exploitation,
            scope=current_scope,
            defaults={"addition_method": "Scan", "linking": linking},
        )

    logger.info("SPDX import done", datetime.now())


# Function derivated from
# https://github.com/spdx/tools-python/blob/21ea183f72a1179c62ec146a992ec5642cc5f002/spdx/parsers/parse_anything.py
# SPDX-FileCopyrightText: spdx contributors
# SPDX-License-Identifier: Apache-2.0
def parse_spdx_file(spdx_file):
    filename = spdx_file.name
    if filename.endswith(".rdf") or filename.endswith(".rdf.xml"):
        parser = rdf.Parser(rdfbuilders.Builder(), StandardLogger())
    elif filename.endswith(".tag") or filename.endswith(".spdx"):
        parser = tagvalue.Parser(tagvaluebuilders.Builder(), StandardLogger())
        spdx_file = spdx_file.read().decode("utf-8")
    elif filename.endswith(".json"):
        parser = jsonparser.Parser(jsonyamlxmlbuilders.Builder(), StandardLogger())
    elif filename.endswith(".xml"):
        parser = xmlparser.Parser(jsonyamlxmlbuilders.Builder(), StandardLogger())
    elif filename.endswith(".yaml") or filename.endswith(".yml"):
        parser = yamlparser.Parser(jsonyamlxmlbuilders.Builder(), StandardLogger())
    else:
        return None, "FileType Not Supported" + filename

    if hasattr(parser, "build"):
        parser.build()

    return parser.parse(spdx_file)
